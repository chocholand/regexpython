import re
#-*- coding:UTF-8 -*-
#regex object를 만들필요없이 모듈수준의 함수로 일치 가능
#정규표현식 객체는 많이 사용할때만
#묘듈수준의 함수는 한 부분에서 사용할때만
print re.match(r'From\S+','Fromas you').span()  #비공백[^ \t\n\r\f\v] <-- 문자 부류라고 부름
print re.match(r'From\w+','Fromas you').span()  #영문과 숫자[a-zA-Z0-9_]
print re.match(r'From\d+','From1s you').span()  #숫자[0-9]
print re.match(r'From\D+','Fromas you').span()  #비숫자[^0-9]
print re.match(r'From\W+','From as you').span()#비-영문 숫자와일치[^a-zA-Z0-9_]
print re.match(r'From\s+','From as you').span() #공백[ \t\n\r\f\v]
print re.search(r' +','From  korea').span()         #공백 4~6
 
"""
I
IGNORECASE
대소문자 비구별 일치를 수행한다; 문자 부류와 기호문자 문자열은 대소문자를 무시하고 기호에 일치한다. 예를 들어, [A-Z]는 소문자 기호에도 역시 일치할 것이고, 
Spam은 "Spam", "spam", 또는 "spAM"에 일치할 것이다. 이런 소문자변환은 현재 로케일을 고려하지 않은 것이다; LOCALE 표식을 설정해도 마찬가지다.
L
LOCALE
\w, \W, \b, 그리고 \B를 현재 로케일에 의존하게 만든다.
로케일은 언어의 차이를 고려하는 프로그램을 만드는데 도움을 줄 목적으로 만들어진 C 라이브러리의 특징이다. 예를 들어, 프랑스어 텍스트를 처리하고자 하면, 
\w+를 단어에 일치시킬 수 있었으면 하고 바라지만, \w는 오직 문자 부류 [A-Za-z]에만 일치할 뿐이다; 다시 말해 "é" 또는 "ç"에 일치하지 않는다. 
시스템이 제대로 환경설정되어 있고 프랑스어 로케일이 선택되었다면, 특정 C 함수들이 프로그램에게 "é"이 기호로 간주되어야 한다고 말해 줄 것이다. 
정규 표현식을 컴파일할 때 LOCALE 표식을 설정해 놓으면 그 결과로 나온 컴파일 객체가 \w에 대하여 이런 C 함수들을 사용하게 된다; 이것이 더 느리지만, 
\w+를 예상대로 프랑스어 단어에 일치시키도록 할 수 있다.
 
M
MULTILINE
(^ 그리고 $는 아직 설명하지 않았다; 이에 대해서는 섹션 4.1에서 소개할 생각이다.)
보통 ^는 문자열의 처음에서만 일치한다. 그리고 $는 문자열의 끝에서만 일치하고, (혹시 있다면) 문자열의 끝에 새줄문자 바로 앞에서 일치한다. 이 표식이 지정되면, 
^는 문자열의 처음과 그 문자열에서 다음에 새줄문자가 나오는 즉시 각 줄의 시작에서 일치한다. 비슷하게, $ 메타문자는 각 줄의 끝과 문자열의 끝에서 일치한다 (각 새줄문자 바로 앞에서).
 
S
DOTALL
특수 문자 "."을 새줄문자를 포함하여 어떤 문자에도 일치하게 만든다; 이 표식이 없으면, "."는 새줄문자를 제외하고 어느 문자에도 일치한다.
X
VERBOSE
이 표식을 사용하면 더 유연하게 정규 표현식의 모양을 만들수 있어서 정규 표현식을 더 읽기 쉽게 만들 수 있다. 이 표식이 지정되면, RE 문자열 안의 공백은 무시된다. 
단 공백이 문자 부류 안에 있거나 앞에 피신되지 않은 역사선이 있는 경우는 제외 된다; 이렇게 하면 RE를 보다 선명하게 들여쓰고 조직화할 수 있다. 
또한 RE 안에 주석을 달 수 도 있는데 엔진이 무시한다; 주석은 "#"로 표시되며 이 문자는 문자 부류 안에 있어서도 안되고 앞에 피신되지 않는 역사선이 와도 안된다.
"""